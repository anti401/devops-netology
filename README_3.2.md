devops-netology 
### Домашнее задание к занятию «3.2. Работа в терминале, лекция 2»  

#### 1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
    vagrant@vagrant:~$ type cd
    cd is a shell builtin
Команда встроена в bash. Что логично, поскольку она меняет текущую директорию для командной оболочки.

#### 2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?
    grep -c <some_string> <some_file>

#### 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
    vagrant@vagrant:~$ pstree -p
    systemd(1)─┬─...

#### 4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
    # ввод на pts/0
    vagrant@vagrant:~$ ls error-test 2>/dev/pts/1
    # вывод на pts/1
    vagrant@vagrant:~$ ls: cannot access 'error-test': No such file or directory

#### 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
    vagrant@vagrant:~$ grep 1 <test.file >test1.file
Вывод всех строк содержащих `1` из файла `test.file` в файл `test1.file`.

#### 6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
    echo test >/dev/tty1
Должно работать что-то подобное, но подключиться посмотреть не удалось.

#### 7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
`bash 5>&1` запустит bash c файловым дескриптором `5` и перенаправлением для него в stdout.  
`echo netology > /proc/$$/fd/5` запишет `netology` в файловый дескриптор `5` bash ($$ - PID bash), из-за перенаправления в stdout `netology` будет выведено в терминал.

#### 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?
    vagrant@vagrant:~$ ls test.file error-test 5>&2 2>&1 1>&5 | grep e
    test.file
    ls: cannot access 'error-test': No such file or directory
Первая строка выводится как stdout `ls`, вторая с подсветкой как вывод `grep`.

#### 9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
Переменные окружения. Можно вывести их командой `env`.

#### 10. Используя man, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
`/proc/<PID>/cmdline` содержит команду со всеми её аргументами, разделёнными символом \0.  
`/proc/<PID>/exe` содержит символьную ссылку до файла запущенного процесса.

#### 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
    vagrant@vagrant:~$ grep -o 'sse[0-9_]*' /proc/cpuinfo
SSE 4.2

#### 12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Однако `ssh localhost 'tty'` вернёт `not a tty`. Как изменить это поведение?
Для `ssh` есть параметр `-t`. Но пусть и без ошибки `not a tty`, соединение сразу закрывается.

    vagrant@vagrant:~$ ssh -t localhost 'tty'
    vagrant@localhost's password:
    /dev/pts/3
    Connection to localhost closed.

#### 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
    ctrl+z
    disown name_of_process
    screen
    reptyr $(pgrep name_of_process)
Пока только ознакомился с инструкцией.

#### 14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
`tee` занимается непосредственно записью в файл (чего `echo` не делает), поэтому `sudo` позволяет получить права на запись.
